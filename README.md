A custom 4-bit CPU I designed and implemented using Verilog HDL. This project demonstrates how a processor functions at a low level, including instructions like fetch, decode, execution, and write-back. The architecture contains a 4-bit datapath, with an ALU capable of basic arithmetic and logic, a program counter for instruction sequencing, registers for data storage, and a control unit that interprets opcodes and drives the internal signals accordingly. All modules operate synchronously with the clock, and a reset input will initialize the CPU to a previous known state before execution begins.

The 4-Bit CPU is capable of running a small instruction for basic operations such as arithmetic, bitwise logic, jumps or branches, and even halting. Instructions are loaded into the instruction register, decoded, and fully processed in the ALU, then stored or forwarded based on the control path for future inputs. I've included a testbench for each module, including simulation so waveforms and internal signals can be inspected to verify correct CPU behavior for each seperate functionality. This design was simulated using tools such as Verilog HDL, Quartus, and ModelSim for visual output.

This project was a foundation for learning computer architecture and digital design at the HDL level. Being only a 4-Bit cpu, with relatively low complexity, it was crucial to learn and understand fundementals of Verilog, with potential future upgrades like expanding the CPU to 8 bits, adding more instructions, implementing pipelining, creating a memory-mapped I/O, or even synthesizing the design onto an FPGA to run real programs.
